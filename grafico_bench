import time
import tracemalloc
import matplotlib.pyplot as plt
import csv

from matrizEsparsa import matrizEsparsa
from matriz2 import sparse_matrix


# ======================================================
#  MEDI√á√ÉO DE TEMPO E MEM√ìRIA
# ======================================================

def medir_tempo(func):
    inicio = time.perf_counter()
    func()
    fim = time.perf_counter()
    return fim - inicio


def medir_memoria(func):
    tracemalloc.start()
    func()
    _, mem_pico = tracemalloc.get_traced_memory()
    tracemalloc.stop()
    return mem_pico / 1024  # KB


# ======================================================
#  MATRIZ TRADICIONAL
# ======================================================

def criar_matriz_tradicional(N, elementos):
    mat = []
    for i in range(N):
        linha = []
        for j in range(N):
            linha.append(0)
        mat.append(linha)
    for (i, j, v) in elementos:
        mat[i][j] = v
    return mat


def soma_tradicional(A, B, N):
    C = []
    for i in range(N):
        linha = []
        for j in range(N):
            linha.append(0)
        C.append(linha)
    for i in range(N):
        for j in range(N):
            C[i][j] = A[i][j] + B[i][j]
    return C


def multiplica_escalar_tradicional(A, k, N):
    C = []
    for i in range(N):
        linha = []
        for j in range(N):
            linha.append(0)
        C.append(linha)
    for i in range(N):
        for j in range(N):
            C[i][j] = A[i][j] * k
    return C


def multiplica_matrizes_tradicional(A, B, N):
    C = []
    for i in range(N):
        linha = []
        for j in range(N):
            linha.append(0)
        C.append(linha)
    for i in range(N):
        for k_idx in range(N): 
            if A[i][k_idx] != 0:
                for j in range(N):
                    C[i][j] += A[i][k_idx] * B[k_idx][j]
    return C


def transpor_tradicional(A, N):
    T = []
    for i in range(N):
        linha = []
        for j in range(N):
            linha.append(0)
        T.append(linha)
    for i in range(N):
        for j in range(N):
            T[j][i] = A[i][j]
    return T


# ======================================================
#  MATRIZ ESPARSA BASEADA EM DICTS
# ======================================================

def criar_matriz_esparsa_dict(rows, cols):
    return {"rows": rows, "cols": cols, "data": {}}


def get_dict(A, i, j):
    return A["data"].get(i, {}).get(j, 0)


def set_val_dict(A, i, j, value):
    if value == 0:
        if i in A["data"] and j in A["data"][i]:
            del A["data"][i][j]
            if not A["data"][i]:
                del A["data"][i]
    else:
        A["data"].setdefault(i, {})[j] = value


def transpor_dict(A):
    T = criar_matriz_esparsa_dict(A["cols"], A["rows"])
    for i, row in A["data"].items():
        for j, v in row.items():
            set_val_dict(T, j, i, v)
    return T


def somar_dict(A, B):
    C = criar_matriz_esparsa_dict(A["rows"], A["cols"])
    for i, row in A["data"].items():
        for j, v in row.items():
            set_val_dict(C, i, j, v)
    for i, row in B["data"].items():
        for j, v in row.items():
            set_val_dict(C, i, j, get_dict(C, i, j) + v)
    return C


def escalar_dict(alpha, A):
    C = criar_matriz_esparsa_dict(A["rows"], A["cols"])
    for i, row in A["data"].items():
        for j, v in row.items():
            set_val_dict(C, i, j, alpha * v)
    return C


def multiplicar_dict(A, B):
    C = criar_matriz_esparsa_dict(A["rows"], B["cols"])

    for i, rowA in A["data"].items():
        for k, vA in rowA.items():
            if k not in B["data"]:
                continue
            for j, vB in B["data"][k].items():
                set_val_dict(C, i, j, get_dict(C, i, j) + vA * vB)

    return C


# ======================================================
#  BENCHMARK
# ======================================================

def benchmark(Ns, sparsity):

    ops = ["GET", "SOMA", "ESCALAR", "MULT", "TRANSP"]

    tempo = {op: [] for op in ops}
    memoria = {op: [] for op in ops}

    tempo.update({op + "_trad": [] for op in ops})
    memoria.update({op + "_trad": [] for op in ops})

    tempo.update({op + "_dict": [] for op in ops})
    memoria.update({op + "_dict": [] for op in ops})

    for N in Ns:
        print(f"\n---- Rodando N={N} ----")
        elementos = sparse_matrix(N, sparsity, seed=123)

        # MATRIZ ESPARSA ORIGINAL
        mA = matrizEsparsa()
        mB = matrizEsparsa()
        for (i, j, v) in elementos:
            mA.set(i, j, v)
            mB.set(i, j, v)

        # DICT
        A_dict = criar_matriz_esparsa_dict(N, N)
        B_dict = criar_matriz_esparsa_dict(N, N)
        for (i, j, v) in elementos:
            set_val_dict(A_dict, i, j, v)
            set_val_dict(B_dict, i, j, v)

        # TRADICIONAL
        A = criar_matriz_tradicional(N, elementos)
        B = criar_matriz_tradicional(N, elementos)

        # ------------------ GET ------------------
        tempo["GET"].append(medir_tempo(lambda: [mA.get(i, j) for (i, j, _) in elementos]))
        memoria["GET"].append(medir_memoria(lambda: [mA.get(i, j) for (i, j, _) in elementos]))

        tempo["GET_dict"].append(medir_tempo(lambda: [get_dict(A_dict, i, j) for (i, j, _) in elementos]))
        memoria["GET_dict"].append(medir_memoria(lambda: [get_dict(A_dict, i, j) for (i, j, _) in elementos]))

        tempo["GET_trad"].append(medir_tempo(lambda: [A[i][j] for (i, j, _) in elementos]))
        memoria["GET_trad"].append(medir_memoria(lambda: [A[i][j] for (i, j, _) in elementos]))

        # ------------------ SOMA ------------------
        tempo["SOMA"].append(medir_tempo(lambda: mA.soma(mB)))
        memoria["SOMA"].append(medir_memoria(lambda: mA.soma(mB)))

        tempo["SOMA_dict"].append(medir_tempo(lambda: somar_dict(A_dict, B_dict)))
        memoria["SOMA_dict"].append(medir_memoria(lambda: somar_dict(A_dict, B_dict)))

        tempo["SOMA_trad"].append(medir_tempo(lambda: soma_tradicional(A, B, N)))
        memoria["SOMA_trad"].append(medir_memoria(lambda: soma_tradicional(A, B, N)))

        # ------------------ ESCALAR ------------------
        tempo["ESCALAR"].append(medir_tempo(lambda: mA.multiplica_escalar(3)))
        memoria["ESCALAR"].append(medir_memoria(lambda: mA.multiplica_escalar(3)))

        tempo["ESCALAR_dict"].append(medir_tempo(lambda: escalar_dict(3, A_dict)))
        memoria["ESCALAR_dict"].append(medir_memoria(lambda: escalar_dict(3, A_dict)))

        tempo["ESCALAR_trad"].append(medir_tempo(lambda: multiplica_escalar_tradicional(A, 3, N)))
        memoria["ESCALAR_trad"].append(medir_memoria(lambda: multiplica_escalar_tradicional(A, 3, N)))

        # ------------------ MULTIPLICA√á√ÉO ------------------
        if N <= 500:
            tempo["MULT"].append(medir_tempo(lambda: mA.multiplica_matrizes(mB)))
            memoria["MULT"].append(medir_memoria(lambda: mA.multiplica_matrizes(mB)))

            tempo["MULT_dict"].append(medir_tempo(lambda: multiplicar_dict(A_dict, B_dict)))
            memoria["MULT_dict"].append(medir_memoria(lambda: multiplicar_dict(A_dict, B_dict)))

            tempo["MULT_trad"].append(medir_tempo(lambda: multiplica_matrizes_tradicional(A, B, N)))
            memoria["MULT_trad"].append(medir_memoria(lambda: multiplica_matrizes_tradicional(A, B, N)))
        else:
            tempo["MULT"].append(None)
            memoria["MULT"].append(None)
            tempo["MULT_dict"].append(None)
            memoria["MULT_dict"].append(None)
            tempo["MULT_trad"].append(None)
            memoria["MULT_trad"].append(None)

        # ------------------ TRANSPOR ------------------
        tempo["TRANSP"].append(medir_tempo(lambda: mA.transpor()))
        memoria["TRANSP"].append(medir_memoria(lambda: mA.transpor()))

        tempo["TRANSP_dict"].append(medir_tempo(lambda: transpor_dict(A_dict)))
        memoria["TRANSP_dict"].append(medir_memoria(lambda: transpor_dict(A_dict)))

        if N <= 800:
            tempo["TRANSP_trad"].append(medir_tempo(lambda: transpor_tradicional(A, N)))
            memoria["TRANSP_trad"].append(medir_memoria(lambda: transpor_tradicional(A, N)))
        else:
            tempo["TRANSP_trad"].append(None)
            memoria["TRANSP_trad"].append(None)

    return tempo, memoria


# ======================================================
#  GERAR GR√ÅFICOS
# ======================================================

def gerar_graficos(Ns, tempo, memoria):

    ops = ["GET", "SOMA", "ESCALAR", "MULT", "TRANSP"]

    for op in ops:
        plt.figure()

        for suf, label in [("", "Esparsa Original"),
                           ("_dict", "Esparsa Dict"),
                           ("_trad", "Tradicional")]:

            xs = [Ns[i] for i in range(len(Ns)) if tempo[op + suf][i] is not None]
            ys = [tempo[op + suf][i] for i in range(len(Ns)) if tempo[op + suf][i] is not None]

            if xs:
                plt.plot(xs, ys, label=label)

        plt.title(f"Tempo ‚Äî {op}")
        plt.xlabel("N")
        plt.ylabel("Tempo (s)")
        plt.grid()
        plt.legend()
        plt.savefig(f"tempo_{op}.png")

    for op in ops:
        plt.figure()
        for suf, label in [("", "Esparsa Original"),
                           ("_dict", "Esparsa Dict"),
                           ("_trad", "Tradicional")]:

            xs = [Ns[i] for i in range(len(Ns)) if memoria[op + suf][i] is not None]
            ys = [memoria[op + suf][i] for i in range(len(Ns)) if memoria[op + suf][i] is not None]

            if xs:
                plt.plot(xs, ys, label=label)

        plt.title(f"Mem√≥ria ‚Äî {op}")
        plt.xlabel("N")
        plt.ylabel("Mem√≥ria Pico (KB)")
        plt.grid()
        plt.legend()
        plt.savefig(f"mem_{op}.png")


# ======================================================
#  GERAR CSV COMPLETO
# ======================================================

def gerar_csv_resultados(Ns, tempo, memoria, nome_arquivo="resultados_benchmark.csv"):
    ops = ["GET", "SOMA", "ESCALAR", "MULT", "TRANSP"]

    modelos = [
        ("", "Esparsa Original"),
        ("_dict", "Esparsa Dict"),
        ("_trad", "Tradicional")
    ]

    with open(nome_arquivo, mode="w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)

        # Cabe√ßalho do CSV
        writer.writerow([
            "Opera√ß√£o",
            "N",
            "Modelo",
            "Tempo (s)",
            "Mem√≥ria Pico (KB)"
        ])

        # Linhas
        for op in ops:
            for suf, nome_modelo in modelos:
                for i in range(len(Ns)):
                    tempo_val = tempo[op + suf][i]
                    mem_val = memoria[op + suf][i]

                    if tempo_val is None:
                        continue

                    writer.writerow([
                        op,
                        Ns[i],
                        nome_modelo,
                        f"{tempo_val:.6f}",
                        f"{mem_val:.3f}"
                    ])

    print(f"üìÑ CSV gerado: {nome_arquivo}")


# ======================================================
#  MAIN
# ======================================================

if __name__ == "__main__":
    Ns = [50, 300, 500, 1000, 10000]
    sparsity = 5

    tempo, memoria = benchmark(Ns, sparsity)

    gerar_graficos(Ns, tempo, memoria)
    gerar_csv_resultados(Ns, tempo, memoria)

    print("\nüèÅ Benchmark finalizado! Gr√°ficos e CSV foram gerados.\n")
